import "forge-std/Test.sol";
import { MSAHooks as MSA } from "miniMSA/MSA_withHooks.sol";
import { IModuleBase as IModule } from "miniMSA/interfaces/IModule.sol";
import { IMSA_Exec } from "miniMSA/interfaces/IMSA.sol";
import { HookManager } from "miniMSA/core/HookManager.sol";
import { MSABootstrap as Bootstrap, BootstrapConfig } from "miniMSA/utils/Bootstrap.sol";
import "src/subaccounts/ColdStoragev2/OwnableValidator.sol";
import "src/subaccounts/ColdStoragev2/OwnableExecutor.sol";
import "src/subaccounts/ColdStoragev2/WithdrawLockHook.sol";
import "erc7579/interfaces/IModule.sol";

import "src/fallbackHandlers/FallbackHandler.sol";
import { FlashloanLender } from "src/subaccounts/FlashLoan/FlashloanLender.sol";
import { FlashloanCallback } from "src/subaccounts/FlashLoan/FlashloanCallback.sol";
import "src/subaccounts/FlashLoan/Common.sol";
import "solady/test/utils/mocks/MockERC721.sol";

contract Target {
    uint256 public value;

    function setValue(uint256 _value) public returns (uint256) {
        value = _value;
        return _value;
    }
}

contract ColdStorageMSA is Test {
    MSA mainAccount;
    MSA subAccount;
    OwnableValidator ownableValidator;
    OwnableExecutor ownableExecutor;

    WithdrawLockHook lockHook;

    Bootstrap bootstrap;

    Target target;

    FlashloanLender flashloanLender;
    FlashloanCallback flashloanCallback;

    MockERC721 erc721;

    function setUp() public {
        vm.roll(14_600_000);
        erc721 = new MockERC721();
        target = new Target();
        vm.label(address(target), "target");
        bootstrap = new Bootstrap();
        mainAccount = new MSA();
        vm.label(address(mainAccount), "mainAccount");
        subAccount = new MSA();
        vm.label(address(subAccount), "subAccount");

        erc721.mint(address(subAccount), 1);

        MockValidator validator = new MockValidator();
        vm.label(address(validator), "validator");
        ownableValidator = new OwnableValidator();
        vm.label(address(ownableValidator), "ownableValidator");
        ownableExecutor = new OwnableExecutor();
        vm.label(address(ownableExecutor), "ownableExecutor");

        FallbackHandler fallbackHandler = new FallbackHandler();

        flashloanLender = new FlashloanLender(address(fallbackHandler));
        flashloanCallback = new FlashloanCallback(address(fallbackHandler));

        lockHook = new WithdrawLockHook();

        // setup bootstrap for subAccount
        BootstrapConfig[] memory validators = new BootstrapConfig[](1);
        validators[0] = BootstrapConfig({
            module: IModule(address(ownableValidator)),
            data: abi.encode(address(mainAccount))
        });
        BootstrapConfig[] memory executors = new BootstrapConfig[](2);
        executors[0] = BootstrapConfig({
            module: IModule(address(ownableExecutor)),
            data: abi.encode(address(mainAccount))
        });

        executors[1] =
            BootstrapConfig({ module: IModule(address(flashloanLender)), data: abi.encode() });

        bytes4[] memory whitelistedFunctionSigs = new bytes4[](1);
        whitelistedFunctionSigs[0] = IERC3156FlashBorrower.onFlashLoan.selector;
        // BootstrapConfig memory hookConfig = BootstrapConfig({
        //     module: IModule(address(lockHook)),
        //     data: abi.encode(1 days, whitelistedFunctionSigs)
        // });

        BootstrapConfig memory hookConfig =
            BootstrapConfig({ module: IModule(address(0)), data: "" });

        bytes4[] memory fallbackSigs = new bytes4[](1);
        fallbackSigs[0] = IERC3156FlashLender.flashLoan.selector;
        FallBackType[] memory flallBackTypes = new FallBackType[](1);
        flallBackTypes[0] = FallBackType.NonStatic;
        address[] memory fallbackHandlers = new address[](1);
        fallbackHandlers[0] = address(flashloanLender);
        BootstrapConfig memory fallbackConfig = BootstrapConfig({
            module: IModule(address(fallbackHandler)),
            data: abi.encode(fallbackSigs, flallBackTypes, fallbackHandlers)
        });

        bytes memory bootstrapCode =
            bootstrap._getInitMSACalldata(validators, executors, hookConfig, fallbackConfig);

        subAccount.initializeAccount(abi.encode(address(bootstrap), bootstrapCode));
        // ----------------------------------------------

        // setup bootstrap for mainAccount
        validators[0] = BootstrapConfig({ module: IModule(address(validator)), data: "" });
        executors = new BootstrapConfig[](1);
        executors[0] = BootstrapConfig({ module: IModule(address(flashloanCallback)), data: "" });

        hookConfig = BootstrapConfig({ module: IModule(address(0)), data: abi.encode() });

        fallbackSigs = new bytes4[](1);
        fallbackSigs[0] = IERC3156FlashBorrower.onFlashLoan.selector;
        flallBackTypes = new FallBackType[](1);
        flallBackTypes[0] = FallBackType.NonStatic;
        fallbackHandlers = new address[](1);
        fallbackHandlers[0] = address(flashloanCallback);
        fallbackConfig = BootstrapConfig({
            module: IModule(address(fallbackHandler)),
            data: abi.encode(fallbackSigs, flallBackTypes, fallbackHandlers)
        });

        bootstrapCode =
            bootstrap._getInitMSACalldata(validators, executors, hookConfig, fallbackConfig);
        mainAccount.initializeAccount(abi.encode(address(bootstrap), bootstrapCode));
    }

    function transaction() public {
        vm.prank(address(mainAccount));
        bytes memory ret = ownableExecutor.executeOnSubAccount(
            IMSA(address(subAccount)), address(target), 0, abi.encodeCall(Target.setValue, 0x4141)
        );
        uint256 retval = abi.decode(ret, (uint256));

        assertEq(retval, 0x4141);
    }

    function activateHook() public {
        vm.prank(address(mainAccount));

        bytes memory ret = ownableExecutor.executeOnSubAccount(
            IMSA(address(subAccount)),
            address(subAccount),
            0,
            abi.encodeCall(HookManager.enableHook, (address(lockHook), abi.encode(1 days)))
        );
    }

    function requestWithdraw() public {
        vm.prank(address(mainAccount));
        ownableExecutor.executeOnSubAccount(
            IMSA(address(subAccount)),
            address(lockHook),
            0,
            abi.encodeWithSelector(WithdrawLockHook.requestWithdraw.selector)
        );
    }

    function test_activateHook() public {
        requestWithdraw();

        vm.warp(1 days + 1);
        transaction();
        transaction();
    }

    function test_flashloan() public {
        vm.prank(address(mainAccount));

        address[] memory targets = new address[](2);
        uint256[] memory values = new uint256[](2);
        bytes[] memory datas = new bytes[](2);

        targets[0] = address(target);
        values[0] = 0;
        datas[0] = abi.encodeCall(Target.setValue, 0x4141);

        targets[1] = address(erc721);
        values[1] = 0;
        datas[1] =
            abi.encodeCall(IERC721.transferFrom, (address(mainAccount), address(subAccount), 1));

        bytes memory batchExec =
            abi.encodeCall(IMSA_Exec.executeBatchFromModule, (targets, values, datas));

        bytes memory encodededData = abi.encode(FlashLoanType.ERC721, hex"41414141", batchExec);
        IERC3156FlashLender(address(subAccount)).flashLoan(
            IERC3156FlashBorrower(address(mainAccount)), address(erc721), 1, encodededData
        );
    }
}

contract MockValidator is IValidator {
    function enable(bytes calldata data) external override { }

    function disable(bytes calldata data) external override { }

    function validateUserOp(
        IERC4337.UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    )
        external
        override
        returns (uint256)
    {
        bytes4 execSelector = bytes4(userOp.callData[:4]);

        return VALIDATION_SUCCESS;
    }

    function isValidSignature(
        bytes32 hash,
        bytes calldata data
    )
        external
        view
        override
        returns (bytes4)
    { }
}
