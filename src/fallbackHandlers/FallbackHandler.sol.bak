// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity >=0.7.0 <0.9.0;

import "erc7579/interfaces/IModule.sol";

abstract contract ERC2771Context {
    error ERC2771Unauthorized();

    modifier onlySmartAccount() {
        _onlySmartAccount();
        _;
    }

    function _onlySmartAccount() private view {
        if (_msgSender() != msg.sender) {
            revert ERC2771Unauthorized();
        }
    }

    function _msgSender() internal view virtual returns (address sender) {
        assembly {
            sender := shr(96, calldataload(sub(calldatasize(), 20)))
        }
    }

    function _manager() internal view virtual returns (address manager) {
        manager = msg.sender;
    }
}

interface IFallbackMethod {
    function handle(
        address account,
        address sender,
        uint256 value,
        bytes calldata data
    )
        external
        returns (bytes memory result);
}

interface IStaticFallbackMethod {
    function handle(
        address account,
        address sender,
        uint256 value,
        bytes calldata data
    )
        external
        view
        returns (bytes memory result);
}

enum FallBackType {
    Static,
    NonStatic
}

contract FallbackHandler is ERC2771Context, IFallback {
    function enable(bytes calldata data) external override {
        (bytes4[] memory selector, FallBackType[] memory fallbackType, address[] memory handler) =
            abi.decode(data, (bytes4[], FallBackType[], address[]));

        uint256 length = selector.length;
        if (length != fallbackType.length || length != handler.length) revert();
        for (uint256 i; i < length; i++) {
            _setFunctionSig(msg.sender, selector[i], fallbackType[i], handler[i]);
        }
    }

    function disable(bytes calldata) external override { }
    // --- events ---

    event SetFunctionSig(
        address indexed account, bytes4 selector, FallBackType fallbackType, address handler
    );
    event RemovedFunctionSelector(address indexed account, bytes4 selector);

    // --- storage ---

    struct FallbackConfig {
        FallBackType fallbackType;
        address handler;
    }

    mapping(address account => mapping(bytes4 => FallbackConfig)) public fallbackHandlers;

    // --- internal ---

    function _setFunctionSig(
        address account,
        bytes4 selector,
        FallBackType fallbackType,
        address handler
    )
        internal
    {
        fallbackHandlers[account][selector] =
            FallbackConfig({ fallbackType: fallbackType, handler: handler });
        emit SetFunctionSig(account, selector, fallbackType, handler);
    }

    function setFunctionSig(
        address account,
        bytes4 selector,
        FallBackType fallbackType,
        address handler
    )
        external
        onlySmartAccount
    {
        _setFunctionSig(account, selector, fallbackType, handler);
    }

    fallback(bytes calldata) external returns (bytes memory result) {
        require(msg.data.length >= 24, "invalid method selector");
        FallbackConfig memory fallbackConfig = fallbackHandlers[msg.sender][msg.sig];
        address erc2771Sender = _msgSender();
        if (fallbackConfig.handler == address(0)) revert();

        if (fallbackConfig.fallbackType == FallBackType.Static) {
            result = IStaticFallbackMethod(fallbackConfig.handler).handle(
                msg.sender,
                erc2771Sender,
                0,
                msg.data[:msg.data.length - 20] // remove ERC2771 sender
            );
        } else {
            result = IFallbackMethod(fallbackConfig.handler).handle(
                msg.sender,
                erc2771Sender,
                0,
                msg.data[:msg.data.length - 20] // remove ERC2771 sender
            );
        }
    }
}
